#!/bin/bash
# git x <dirs...> -- clone|pull|push|grep|config|checkout
paths=()
# https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
is_first_double_dash_handled=0
while [[ "$1" != "--" ]]; do
  paths+=($1)
  shift
done
shift
if [[ $# == 0 ]]; then
  echo "No git subcommand specified!"
  exit 1
fi
sub_cmd=$1
shift

function print_meta() {
  echo -e "\033[0;31m## $1: \033[4m$(git -C $1 config --get remote.origin.url)\033[24m\033[0m"
}

function realpath {
  echo $(cd $(dirname $1); pwd)/$(basename $1);
}

function grep() {
  path=$1
  shift
  slash="/"
  escaped="\/"
  # https://stackoverflow.com/questions/3915040/how-to-obtain-the-absolute-path-of-a-file-via-shell-bash-zsh-sh
  # root=$(realpath $path)
  # https://stackoverflow.com/questions/13210880/replace-one-substring-for-another-string-in-shell-script
  # root="${root//$slash/$escaped}"
  root="${path//$slash/$escaped}"
  # https://stackoverflow.com/questions/2327191/preserve-colouring-after-piping-grep-to-grep
  # https://askubuntu.com/questions/674333/how-to-pass-an-array-as-function-argument
  git -C $path grep --color=always "$@" |sed "s/^.*/$root\/&/"
}

function del() {
  path=$1
  shift
  flag="-d"
  if [[ $1 == "-D" ]]; then
    flag=$1
    shift
  fi
  if [[ $# == 0 ]]; then
    echo "No pattern specified."
    exit 0
  fi
  # git branch $flag `git branch --list "$@"`
  print_meta $path
  git -C $path branch $flag $(git -C $path branch --list "$@")
  # echo `git branch --list "$@"`
}

function exec_native_git_cmd() {
  path=$1
  shift
  print_meta $path
  git -C $path $sub_cmd "$@"
}

function exec_custom_git_cmd() {
  $sub_cmd "$@"
}

if [[ $(declare -F "$sub_cmd") == "" ]]; then
  cmd="exec_native_git_cmd"
else
  cmd="exec_custom_git_cmd"
fi

for path in "${paths[@]}"
do
  if [[ -d $path && -d "$path/.git" ]]; then
    $cmd $path "$@"
  fi
done

